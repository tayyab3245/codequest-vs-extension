<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modern Patterns Preview</title>
    <link rel="stylesheet" href="media/dashboard/patterns/patterns.css">
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: var(--bg-primary);
            font-family: var(--font-family);
        }
        .preview-note {
            background: var(--bg-secondary);
            border-radius: var(--border-radius);
            padding: 1rem;
            margin-bottom: 2rem;
            box-shadow: var(--shadow-inset);
            color: var(--text-primary);
        }
    </style>
</head>
<body>
    <div class="preview-note">
        <h2>âœ… Modern Neumorphic Patterns Integration Complete</h2>
        <p>This preview shows the successfully integrated modern patterns design with:</p>
        <ul>
            <li>ðŸŽ¨ Modern neumorphic styling with soft shadows and gradients</li>
            <li>ðŸ“± Responsive grid layout for pattern cards</li>
            <li>ðŸ”§ Seamless integration with existing timer and solve functionality</li>
            <li>ðŸŽ¯ Modular CSS architecture for maintainability</li>
            <li>âš¡ All original functionality preserved</li>
        </ul>
    </div>

    <div id="patterns-list">
        <!-- Patterns will be rendered here by render.js -->
    </div>

    <!-- Simulate the global data that would be available -->
    <script>
        window.__catalogData__ = {
            "array": { /* mock data */ },
            "binary-search": { /* mock data */ },
            "dynamic-programming": { /* mock data */ }
        };
        
        window.__catalogNames__ = {
            "array": "Array Patterns",
            "binary-search": "Binary Search",
            "dynamic-programming": "Dynamic Programming"
        };
    </script>

    <script type="module">
        // Mock the dependencies for preview
        const state = { solvedProblems: new Set() };
        const openPanel = { pattern: null, segIndex: null };
        
        window.setOpenPanel = (panel) => Object.assign(openPanel, panel);
        window.setSelectedKey = (key) => console.log('Selected:', key);
        window.buildSegments = (pattern) => Array.from({length: 20}, (_, i) => ({
            title: `Problem ${i+1}`,
            slug: `problem-${i+1}`,
            difficulty: ['Easy', 'Medium', 'Hard'][i % 3],
            solved: Math.random() > 0.7,
            isVariant: Math.random() > 0.8,
            isGenerated: Math.random() > 0.9
        }));
        window.formatTime = (seconds) => {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        };
        window.postMessage = (msg) => console.log('Message:', msg);

        // Create a simplified version of renderPatterns for preview
        function renderPatternsPreview() {
            const patternsList = document.getElementById('patterns-list');
            if (!patternsList) return;

            // Create modern container structure
            const containerWrapper = document.createElement('div');
            containerWrapper.className = 'patterns-container-wrapper';

            // Create header with legend
            const header = document.createElement('div');
            header.className = 'patterns-main-header';

            const title = document.createElement('h2');
            title.textContent = 'Algorithm Patterns';
            header.appendChild(title);

            const legend = document.createElement('div');
            legend.className = 'patterns-legend';
            
            const legendItems = [
                { status: 'unsolved', label: 'Unsolved' },
                { status: 'attempted', label: 'Attempted' },
                { status: 'solved', label: 'Solved' }
            ];

            legendItems.forEach(item => {
                const legendItem = document.createElement('div');
                legendItem.className = 'patterns-legend-item';
                
                const indicator = document.createElement('span');
                indicator.className = `status-indicator ${item.status}`;
                
                const label = document.createTextNode(item.label);
                
                legendItem.appendChild(indicator);
                legendItem.appendChild(label);
                legend.appendChild(legendItem);
            });

            header.appendChild(legend);

            // Create patterns grid
            const patternsGrid = document.createElement('div');
            patternsGrid.className = 'patterns-grid';

            // Create sample pattern cards
            const patterns = ['Array Patterns', 'Binary Search', 'Dynamic Programming'];
            patterns.forEach((patternName, index) => {
                const patternCard = document.createElement('div');
                patternCard.className = 'pattern-card';
                patternCard.setAttribute('data-progress', index + 1);

                const header = document.createElement('div');
                header.className = 'pattern-header-clickable';

                const title = document.createElement('h3');
                title.className = 'pattern-title';
                title.textContent = patternName;

                const segmentedBar = document.createElement('div');
                segmentedBar.className = 'segmented-bar';
                
                for (let i = 0; i < 5; i++) {
                    const segment = document.createElement('span');
                    segment.className = 'segment';
                    segmentedBar.appendChild(segment);
                }

                header.appendChild(title);
                header.appendChild(segmentedBar);

                const questionsContainer = document.createElement('div');
                questionsContainer.className = 'questions-container';

                // Add sample questions
                for (let i = 0; i < 8; i++) {
                    const questionItem = document.createElement('div');
                    questionItem.className = 'question-item';
                    questionItem.dataset.status = Math.random() > 0.6 ? 'solved' : 'unsolved';

                    const statusIndicator = document.createElement('span');
                    statusIndicator.className = `status-indicator ${questionItem.dataset.status}`;

                    const questionTitle = document.createElement('span');
                    questionTitle.className = 'question-title';
                    questionTitle.textContent = `B${Math.floor(i/4)+1} - Sample Problem ${i+1}`;

                    const actionsWrapper = document.createElement('div');
                    actionsWrapper.className = 'actions';

                    const timer = document.createElement('span');
                    timer.className = 'timer';
                    timer.textContent = '0:00';

                    const startBtn = document.createElement('button');
                    startBtn.className = 'action-btn start-btn';
                    startBtn.textContent = 'Start';

                    const solveBtn = document.createElement('button');
                    solveBtn.className = 'action-btn solve-btn-icon';
                    solveBtn.innerHTML = questionItem.dataset.status === 'solved' ? 
                        '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" /></svg>' :
                        '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M4.5 12.75l6 6 9-13.5" /></svg>';
                    
                    if (questionItem.dataset.status === 'solved') {
                        solveBtn.classList.add('is-solved');
                    }

                    actionsWrapper.append(timer, startBtn, solveBtn);
                    questionItem.append(statusIndicator, questionTitle, actionsWrapper);
                    questionsContainer.appendChild(questionItem);
                }

                // Add expand/collapse functionality
                header.addEventListener('click', () => {
                    const isOpen = questionsContainer.style.maxHeight && questionsContainer.style.maxHeight !== '0px';
                    if (isOpen) {
                        questionsContainer.style.maxHeight = '0px';
                        questionsContainer.classList.remove('open');
                    } else {
                        questionsContainer.style.maxHeight = questionsContainer.scrollHeight + 'px';
                        questionsContainer.classList.add('open');
                    }
                });

                patternCard.appendChild(header);
                patternCard.appendChild(questionsContainer);
                patternsGrid.appendChild(patternCard);
            });

            containerWrapper.appendChild(header);
            containerWrapper.appendChild(patternsGrid);

            patternsList.innerHTML = '';
            patternsList.appendChild(containerWrapper);
        }

        // Render on load
        document.addEventListener('DOMContentLoaded', renderPatternsPreview);
    </script>
</body>
</html>
